# 类和对象（重要）
C++面向对象的三大特性：封装、继承、多态  
C++认为万事万物皆为对象，对象上有其属性和行为  
  
## 封装
### 封装的意义
*将属性和行为作为一个整体，表现生活中的事物  
*将属性和行为加以权限控制  
语法：class 类名{访问权限： 属性 / 行为}；  
术语  
实例化：通过类创建对象  
成员：属性+行为  
属性（也称 成员属性，变量属性）  
行为（也称 行为函数，行为方法）  
  
访问权限：  
类在设计时，可以把属性和行为放在不同的权限下加以控制  
1、public 公共权限：    成员 类内外都可访问  
2、protected 保护权限： 成员 类内可以，类外不可以，子类可以访问父类  
3、private 私有权限：   成员 类内可以，类外不可以，子类不可以访问父类  
  
### struct与class区别
唯一区别在于 **默认的访问权限不同**  
* struct默认权限公共  
* class默认权限私有  
  
### 成员属性设置为私有
**优点1：**将所有成员属性设置为私有，可以自己控制读写权限（在公共权限下写函数实现读写操作）  
**优点2：**对于写权限，我们可以检测数据的有效性  
  
## 对象的初始化和清理
### 构造函数和析构函数
C++利用**构造函数**和**析构函数**解决对象的初始化和清理问题，这两个函数将会被编译器自动调用。  
对象的初始化和清理工作是编译器强制我们要做的事，如果**我们不提供构造和析构，编译器会提供**  。
**编译器提供的构造函数和析构函数是空实现**。  
  
* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，无需手动调用。  
* 析构函数：主要作用在于对象销毁前系统自动调用，实现清理工作。  
  
**构造函数语法：**类名(){}  
 1. 构造函数，没有返回值也不写void  
 2. 函数名称与类名相同  
 3. 构造函数可以有参数，因此可以发生重载  
 4. 程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次  
  
**析构函数语法：**~类名(){}  
 1. 析构函数，没有返回值也不写void  
 2. 函数名称与类名相同，在名称前加符号~  
 3. 析构函数不可以有参数，因此不可以发生重载  
 4. 程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次  
  
### 构造函数的分类及调用
两种分类方式：  
&ensp;&ensp;按参数分为：有参构造和无参构造（默认构造）  
&ensp;&ensp;按类型分为：普通构造和拷贝构造  
拷贝构造语法：类名（const 类名& 对象）{属性 = 对象.属性}  
三种调用方式：  
&ensp;&ensp;括号法  
&ensp;&ensp;显示法  
&ensp;&ensp;隐式转换法  
匿名对象：Person(10);特点：当前行执行结束后，系统会立即回收掉该对象  
注意：  
 1.调用默认构造函数的时候，不要加（），因为会被当成函数声明  
 2.不要利用拷贝构造函数初始化匿名对象，编译器会去掉小括号，报错重定义  
  
### 拷贝构造函数调用时期
* 使用一个已经创建完毕的对象来初始化一个新对象  
* 值传递的方式给函数参数传值  
* 以值方式返回局部对象  
  
### 构造函数调用规则
默认情况下，C++编译器至少给一个类添加3个函数  
1. 默认构造函数（无参，函数体为空）  
2. 默认析构函数（无参，函数体为空）  
3. 默认拷贝构造函数，对属性进行值拷贝  
  
构造函数调用规则如下：  
* 如果用户定义有构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造  
* 如果用户定义拷贝构造函数，C++不会再提供其他构造函数  
记法：有了下面的，不提供上面的  
  
### 深拷贝与浅拷贝（面试常问）
  
深拷贝是面试经典问题，也是最常见的一个坑  
  
浅拷贝：简单的赋值拷贝操作（带来问题：堆区的内存重复释放）  
深拷贝：在堆区重新申请空间，进行拷贝操作  
深拷贝就是给拷贝前后分别创建一个堆区，这两个堆区地址不同，但内容相同，从而避免非法操作（重复释放）出现  
  
总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题  
  
### 初始化列表
  
作用：  
C++提供了初始化列表语法，用来初始化属性  
  
语法：构造函数(): 属性1(值1)，属性2(值2)... {}  
例：Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}  
  
### 类对象作为类成员
  
C++类中的成员可以是另一类的对象，我们称该成员为 对象成员  
例如：  
class A {}  
class B {  
&ensp;&ensp;&ensp;&ensp;A a;//a为对象成员  
}  
  
B类中有对象a作为成员，a为对象成员  
那么当创建B的对象时，A与B的构造和析构先后顺序为：先构造A的对象，后构造B的对象；析构顺序相反  
  
### 静态成员
  
静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员  
静态成员分为：  
&ensp;&ensp;* 静态成员变量  
&ensp;&ensp;&ensp;&ensp;所有对象共享同一份数据  
&ensp;&ensp;&ensp;&ensp;在编译阶段分配内存  
&ensp;&ensp;&ensp;&ensp;类内声明，类外初始化  
&ensp;&ensp;* 静态成员函数  
&ensp;&ensp;&ensp;&ensp;所有对象共享一个函数  
&ensp;&ensp;&ensp;&ensp;静态成员函数只能访问静态成员变量  
  
注意：静态成员变量 不属于某个对象上，所有对象都共享同一份数据，因此静态成员变量有两种访问方式：  
1、通过对象进行访问  
2、通过类名进行访问 类名::变量  
  
## C++对象模型和this指针

### 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储  
**只有非静态成员变量才属于类的对象上**  
  
**空对象占用内存为1(面试常问)**：C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置  
成员函数不属于类的对象上，与成员变量分开存储  
  
### this指针概念
每个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会公用一块代码  
问题是：这一块代码如何区分是哪个对象调用自己的呢？  
  
C++通过提供特殊的对象指针，this指针解决上述问题。**this指针指向被调用的成员函数所属的对象（谁调他就指谁）**  
  
this指针是隐含每一个非静态成员函数内的一种指针  
this指针不需要定义，直接使用即可  
	this指针本质是指针常量，指针的指向是不可修改的  
	this相当于Person* p const this;  
  
this指针的用途：  
* 当形参和成员变量同名时，可用this指针来区分（解决名称冲突）  
* 在类的非静态成员函数中返回对象本身，可使用return* this（返回对象本体，函数类型定义为类引用，如Person& func）  
  
### 空指针访问成员函数
  
C++中空指针也是可以调用成员函数的，但是要注意有没有用到this指针(成员函数调用类内成员属性实际就用了this)  
如果用到this指针，则需要加以判断保证代码的强壮性  
  
### const修饰成员函数
**常函数：**  
 * 成员函数后加const后我们称为这个函数为常函数  
 * 常函数内不可以修改成员属性  
 * 成员属性声明时加关键字mutable后，在常函数中依然可以修改，常对象下也可修改(mutable 属性类型 属性名)  
**常对象：**  
 * 声明对象前加const称该对象为常对象  
 * 常对象只能调用常函数  
  
## 友元
  
生活中你的家有客厅(public)，有卧室(private)  
客厅谁都能进，卧室只有自己可以进，但是可以允许好朋友进去。  
  
在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元技术  
  
友元的目的就是 让一个函数或者类 访问 另一个类中私有成员  
  
友元的关键字为 friend  
  
友元的三种实现：  
 * 全局函数做友元  
 * 类做友元  
 * 成员函数做友元  
  
### 全局函数做友元
类里声明全局函数前加关键字friend即可  
### 类做友元
类里声明类前加关键字friend即可  
### 成员函数做友元
类里声明成员函数前加关键字friend(需要标明是类里的成员函数，加作用域::)  
  
## 运算符重载（重要知识点）
  
运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型  
运算符重载也可以发生函数重载  
  
### 加号运算符重载
作用：实现两个自定义数据类型相加的运算  
 总结1：对于内置的数据类型的表达式的运算符是不可能改变的  
 总结2：不要滥用运算符重载  
  
### 左移运算符重载
作用：可以输出自定义数据类型  
只能利用全局函数重载左移运算符  
ostream& operator<<(ostream& cout, Person& p)  
 总结：左移运算符配合友元可以实现输出自定义数据类型  
  
### 递增运算符重载
作用：通过重载递增运算符，实现自己的整型数据  
区分前置和后置，用int占位参数  
后置递增返回值（返回引用会报错，因为局部变量释放掉了），前置递增返回引用  
  
### 赋值运算符重载
C++编译器至少给一个类添加4个函数  
 1、默认构造函数（无参，函数体为空）  
 2、默认析构函数（无参，函数体为空）
 3、默认拷贝构造函数，对属性进行值拷贝  
 4、赋值运算符 operator=，对属性进行值拷贝  
  
如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题  
  
作用：编译器提供的赋值运算符是浅拷贝操作，通过重载实现深拷贝  
  
### 关系运算符重载
作用：重载关系运算符，可以让两个自定义类型对象进行对比操作  
bool operator==(Person& p)  
  
### 函数调用运算符重载
 * 函数调用运算符()也可以重载  
 * 由于重载后使用的方式非常像函数的调用，因此称为仿函数（STL中用的多）  
 * 仿函数没有固定写法，非常灵活  
  
## 继承（重中之重）
**继承是面向对象三大特性之一**  
作用：减少重复代码  
  
### 继承的基本语法
class 子类 : 继承方式 父类  
子类 = 派生类  
父类 = 基类  
  
**派生类中的成员，包含两大部分：**  
一类是从基类继承过来的，一类是自己增加的成员  
从基类继承过来的表现其共性，而新增的成员体现了其个性  
  
### 继承方式
继承方式一共有三种：  
 * 公共继承(除了private其他原封不动照搬)  
 * 保护继承(除了private其他放在protected里)  
 * 私有继承(除了private其他放在private里)  
![](https://github.com/ChenRD98/C-plusplus/blob/master/C%2B%2B%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F.jpg)  
  
### 继承中的对象模型
问题：从父类继承过来的成员，哪些属于子类对象中？  
父类中所有非静态成员属性都会被子类继承下去  
  
使用vs的开发人员命令提示工具可查看类的分布图（对象模型）  
命令为：cl /d1 reportSingleClassLayout类名 "类所在文件名.后缀"  
  
### 继承中构造和析构顺序
子类继承父类后，当创建子类对象，也会调用父类构造函数  
问题：父类和子类的构造和析构顺序是谁先谁后？  
父类构造函数——子类构造函数——子类析构函数——父类析构函数  
面试题：创建一个子类对象会不会有父类对象的创建，顺序是怎么样的？  
  
### 继承同名成员处理方式
问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据？  
  
 * 访问子类同名成员 直接访问即可  
 * 访问父类同名成员 需要加作用域  
 * 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数  
  
同名成员属性处理  子类对象名.父类名::成员属性  
同名成员函数处理  子类对象名.父类名::成员函数  
  
### 继承同名静态成员处理方式
静态成员和非静态成员出现同名，处理方式一致，只不过有两种访问方式（通过对象、通过类名Son::Base::m_A）  
 * 访问子类同名成员 直接访问即可  
 * 访问父类同名成员 需要加作用域  
  
### 多继承语法
C++允许**一个类继承多个类**  
语法：class 子类 : 继承方式 父类1， 继承方式 父类2....  
多继承可能会引发父类中有同名成员出现，需要加作用域区分  
**C++实际开发中不建议用多继承**（因为不同父类可能有同名成员，引用时要加作用域麻烦）  
  
### 菱形继承
概念：  
 两个派生类继承同一个基类  
 又有某个类同时继承这两个派生类  
 这种继承被称为菱形继承，或者钻石继承  
  
带来问题：  
 1、羊继承了动物的属性，驼同样继承了动物的属性，当羊驼使用数据时，会产生二义性（通过作用域可解决）  
 2、羊驼继承自动物的数据继承了两份，其实我们只需要一份（主要问题）  
  
解决方法：虚继承（面试题）  
继承之前 加上关键字 virtual 变为虚继承  
虚继承的基类称为虚基类  
本质：子类继承的是虚基类指针，该指针指向子类的虚基类表，表中记录了偏移量，加上偏移量找到唯一数据  
  
## 多态
### 多态的基本概念
**多态是C++面向对象三大特性之一**  
多态分为两类：  
 * 静态多态：函数重载 和 运算符重载属于静态多态，复用函数名  
 * 动态多态：派生类和虚函数实现运行时多态  
静态多态和动态多态区别：
 * 静态多态的函数地址早绑定 - 编译阶段确定函数地址  
 * 动态多态的函数地址晚绑定 - 运行阶段确定函数地址  
  
虚函数：成员函数定义类型前加关键字virtual  
作用：实现函数地址晚绑定  
  
动态多态满足条件  
 1、有继承关系  
 2、子类要重写父类的虚函数（子类中函数前virtual可省略）  
重写：函数返回值类型、函数名、参数列表 完全相同  
  
动态多态使用：父类的指针或者引用 指向子类对象  
  
动态多态原理剖析：  
成员函数不在类上，内存空间占1，但加上关键字virtual成为虚函数后，占4字节，为vfptr虚函数（表）指针所占用，指向虚函数表vftable，表内记录虚函数的地址&Animal::speak  
Cat子类内部结构继承过来指针vfptr，指向子类的虚函数表，只继承的话表内记录的还是&Animal::speak  
但是发生重写后，表内会替换成子类的虚函数地址&Cat::speak  
当父类的指针或引用指向子类对象时候，发生多态  
  
### 案例一：计算器类
案例描述：  
分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类  
  
多态的优点：  
 * 代码组织结构清晰  
 * 可读性强  
 * 利于前期和后期扩展以及维护  

 