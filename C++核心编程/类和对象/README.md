# 类和对象（重要）
C++面向对象的三大特性：封装、继承、多态  
C++认为万事万物皆为对象，对象上有其属性和行为  
  
## 封装
### 封装的意义
*将属性和行为作为一个整体，表现生活中的事物  
*将属性和行为加以权限控制  
语法：class 类名{访问权限： 属性 / 行为}；  
术语  
实例化：通过类创建对象  
成员：属性+行为  
属性（也称 成员属性，变量属性）  
行为（也称 行为函数，行为方法）  
  
访问权限：  
类在设计时，可以把属性和行为放在不同的权限下加以控制  
1、public 公共权限：    成员 类内外都可访问  
2、protected 保护权限： 成员 类内可以，类外不可以，子类可以访问父类  
3、private 私有权限：   成员 类内可以，类外不可以，子类不可以访问父类  
  
### struct与class区别
唯一区别在于 **默认的访问权限不同**  
* struct默认权限公共  
* class默认权限私有  
  
### 成员属性设置为私有
**优点1：**将所有成员属性设置为私有，可以自己控制读写权限（在公共权限下写函数实现读写操作）  
**优点2：**对于写权限，我们可以检测数据的有效性  
  
## 对象的初始化和清理
### 构造函数和析构函数
C++利用**构造函数**和**析构函数**解决对象的初始化和清理问题，这两个函数将会被编译器自动调用。  
对象的初始化和清理工作是编译器强制我们要做的事，如果**我们不提供构造和析构，编译器会提供**  。
**编译器提供的构造函数和析构函数是空实现**。  
  
* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，无需手动调用。  
* 析构函数：主要作用在于对象销毁前系统自动调用，实现清理工作。  
  
**构造函数语法：**类名(){}  
 1. 构造函数，没有返回值也不写void  
 2. 函数名称与类名相同  
 3. 构造函数可以有参数，因此可以发生重载  
 4. 程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次  
  
**析构函数语法：**~类名(){}  
 1. 析构函数，没有返回值也不写void  
 2. 函数名称与类名相同，在名称前加符号~  
 3. 析构函数不可以有参数，因此不可以发生重载  
 4. 程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次  
  
### 构造函数的分类及调用
两种分类方式：  
&ensp;&ensp;按参数分为：有参构造和无参构造（默认构造）  
&ensp;&ensp;按类型分为：普通构造和拷贝构造  
拷贝构造语法：类名（const 类名& 对象）{属性 = 对象.属性}  
三种调用方式：  
&ensp;&ensp;括号法  
&ensp;&ensp;显示法  
&ensp;&ensp;隐式转换法  
匿名对象：Person(10);特点：当前行执行结束后，系统会立即回收掉该对象  
注意：  
 1.调用默认构造函数的时候，不要加（），因为会被当成函数声明  
 2.不要利用拷贝构造函数初始化匿名对象，编译器会去掉小括号，报错重定义  
  
### 拷贝构造函数调用时期
* 使用一个已经创建完毕的对象来初始化一个新对象  
* 值传递的方式给函数参数传值  
* 以值方式返回局部对象  
  
### 构造函数调用规则
默认情况下，C++编译器至少给一个类添加3个函数  
1. 默认构造函数（无参，函数体为空）  
2. 默认析构函数（无参，函数体为空）  
3. 默认拷贝构造函数，对属性进行值拷贝  
  
构造函数调用规则如下：  
* 如果用户定义有构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造  
* 如果用户定义拷贝构造函数，C++不会再提供其他构造函数  
记法：有了下面的，不提供上面的  
  
### 深拷贝与浅拷贝（面试常问）
  
深拷贝是面试经典问题，也是最常见的一个坑  
  
浅拷贝：简单的赋值拷贝操作（带来问题：堆区的内存重复释放）  
深拷贝：在堆区重新申请空间，进行拷贝操作  
深拷贝就是给拷贝前后分别创建一个堆区，这两个堆区地址不同，但内容相同，从而避免非法操作（重复释放）出现  
  
总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题  
  
### 初始化列表
  
作用：  
C++提供了初始化列表语法，用来初始化属性  
  
语法：构造函数(): 属性1(值1)，属性2(值2)... {}  
例：Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}  
  
### 类对象作为类成员
  
C++类中的成员可以是另一类的对象，我们称该成员为 对象成员  
例如：  
class A {}  
class B {  
&ensp;&ensp;&ensp;&ensp;A a;//a为对象成员  
}  
  
B类中有对象a作为成员，a为对象成员  
那么当创建B的对象时，A与B的构造和析构先后顺序为：先构造A的对象，后构造B的对象；析构顺序相反  
  
### 静态成员
  
静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员  
静态成员分为：  
&ensp;&ensp;* 静态成员变量  
&ensp;&ensp;&ensp;&ensp;所有对象共享同一份数据  
&ensp;&ensp;&ensp;&ensp;在编译阶段分配内存  
&ensp;&ensp;&ensp;&ensp;类内声明，类外初始化  
&ensp;&ensp;* 静态成员函数  
&ensp;&ensp;&ensp;&ensp;所有对象共享一个函数  
&ensp;&ensp;&ensp;&ensp;静态成员函数只能访问静态成员变量  
  
注意：静态成员变量 不属于某个对象上，所有对象都共享同一份数据，因此静态成员变量有两种访问方式：  
1、通过对象进行访问  
2、通过类名进行访问 类名::变量  
  
## C++对象模型和this指针

### 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储  
**只有非静态成员变量才属于类的对象上**  
  
**空对象占用内存为1(面试常问)**：C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置  
成员函数不属于类的对象上，与成员变量分开存储  
  
### this指针概念
每个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会公用一块代码  
问题是：这一块代码如何区分是哪个对象调用自己的呢？  
  
C++通过提供特殊的对象指针，this指针解决上述问题。**this指针指向被调用的成员函数所属的对象（谁调他就指谁）**  
  
this指针是隐含每一个非静态成员函数内的一种指针  
this指针不需要定义，直接使用即可  
  
this指针的用途：  
* 当形参和成员变量同名时，可用this指针来区分（解决名称冲突）  
* 在类的非静态成员函数中返回对象本身，可使用return* this（返回对象本体，函数类型定义为类引用，如Person& func）  
  